
## 영상 데이터 구조

[Array](##array)
- [List](##list)
- [ArrayList](##arrayList)
- [LinkedList](##linkedList)
- [Big-O notation](##big-o-notation)
[UUID](##uuid)
- [Java 메모리](##java-메모리)

## Array

> - Array란 같은 데이터 타입의 변수들로 이루어진 자료구조이다. 
> - 이때 배열을 구성하는 각각의 값을 요소 혹은 원소라 부른다.
> - 배열에서 요소의 위치를 가리키는 숫자는 인덱스라 부른다.
> - 주요한 특징으로는 메모리 공간이 연속적으로 구성되며 배열의 물리주소와 논리주소가 동일하다.  
___

## List
> - List란  같은 데이터 타입의 변수들로 이루어진 점에서는 Array와 유사하지만 배열과는 다르게 저장공간의 크기가 가변적이며 중간에 빈공간이 허용되지 않는다는 특징이있다.
---
## ArrayList
> - List의 특징처럼 ArrayList의 크기는 가변적이며 중간에 빈공간을 허용하지 않는다.
> - 배열의 요소를 복사하여 새로운 배열로 옮기는 과정은 동일하며 그에따른 시간소요또한 동일하다. 
---
## linkedList
> - LinkedList는 Node로 구성된다. Node가 데이터를 담고있고, 이전노드와 다음노드에 대한 정보도 가지고있다.
> - 즉 LinkedList는 데이터부분과 주소부분이 나누어져 있고 이 주소부분이 다음 노드를 가리켜 연결되는 형식이다.
> - LinkedList와 ArrayList,Array와의 차이점중 하나는 메모리 공간에 저장될때 불연속적으로 저장이 된다는 것이다. 
---
## Big-O notation
> - Big-O notation이란 알고리즘 효율성을 표기해주는 표기법 이다.
> - 빅오 표기법(알고리즘 효율성을 상한선 기준으로 표기), 빅오메가(하한선을 기준으로 표기), 빅세타(상한선과 하한선의 사이를 기준으로 표기)
> - 빅오 표기법의 특징  
    - 상수항을 무시한다 EX) 0(2N) -> O(N)  
    - 영향력 없는 항 무시 EX) 0(N^2+2N+1) -> 0(N^2)
> ---
> - (오른쪽으로 갈수록 시간복잡도가 더크다) O(1) < O(logn) < O(n) < O(nlogn) < O(n^2) < O(n^3) < O(2^n) < O(n!) ...

##### 자주사용하는 빅오표기법
> - O(1) : 스택에서 Push, Pop  
> - O(log n) : 이진트리
> - O(n) : for 문
> - O(n log n) : 퀵 정렬(quick sort), 병합정렬(merge sort), 힙 정렬(heap Sort)
> - O(): 이중 for 문, 삽입정렬(insertion sort), 거품정렬(bubble sort), 선택정렬(selection sort)
> - O() : 피보나치 수열

#### 빅오표기법 사용법
> - 만약 우리가 만든 알고리즘의 시간복잡도가 0(NM) (N<=1000, M<=10,000) 이라고 할때  
알고리즘에서 입력이 가장클 경우는 천만번인것을 알수있다.  
평균적으로 컴퓨터가 가장간단한 연산을 1초에 1억번정도 할수있다라고 가정한다면 위 알고리즘은 1초안에 계산이될수있는것이다.  
> ---
> - 근데만약 0(NM) (N<=100,000, M<=10,000) 이라고 한다면  
입력이 가장클경우는 10억번인것을 알수있다.  
이 경우 컴퓨터가 위 알고리즘을 1초안에 계산해낼수없기때문에 시간복잡도가 O(NlogM)인 알고리즘을 구현했다 가정한다면  
(log의 밑이 2라가정 빅오표기법에서 log의 밑을 생략하는경우가 많은데 이 이유는 log의 밑에의하여 알고리즘의 복잡도가 크게 영향을 받지 않아서 이다.)
log10000 = 대략 13 따라서 1,300,000 정도의 연산을 수행하며, 따라서 1초안에 컴퓨터가 알고리즘을 수행할수 있게된다.

---
## UUID
> - **UUID**란 자바에서 제공하는 기본적인클래스로 테이블에서 key로 사용될 수 있는 대표적인 KeyGen의 방법중 하나이다.    
아래와 같이 코드를 짜면 된다.  
> ~~~ java
>  String id = UUID.randomUUID().toString();
>  System.out.println("UUID Value :" + id);
> ~~~
> - 근데 UUID라고 무조건 중복이 없는건 아니고 1초에 2.71 * 10^18 개의 UUID를 생성했을 때 최소 1개가 중복 될 확률이 약 50% 정도라고 한다.
----
## 메모리 
> - Java에서 Stack 이란 Heap 영역에 생성된 Object 타입의 데이터의 참조값이 할당된다.
> - Java에서 Heap 이란 모든 Object 타입(Integer, String, ArrayList, ...)은 heap 영역에 생성된다. 
> - 원시타입(primitive type)은 Stack영역에 직접 값을 가지고있고, 참조타입(reference type)은 Heap영역의 객체주소를 Stack 영역에 가지고있다.
>``` java
>   int argument = 4;
> ```
> - 위코드와 같이 변수를 선언하면 argument 변수의 타입은 원시타입, 따라서 Stack에 argument = 4라는 값이 할당이 되는것이다.
> ---
> - Java에서 변수사용시 원시데이터 타입(원시 데이터타입이란 int..등)을 제외한 reference type(참조타입)은 new로 할당된다.
> ``` Java
> Student st = new Student();
> ```
> - 위와같은 코드를 짜면 Stack 메모리에는 Student st가 Heap메모리에는 new Student()메모리가 들어간다.
> - Heap 메모리에 생성된 new Student()같은 경우는 메모리 어디에 존재하는지 알수없기때문에 new Student()의 주소값을  Stack메모리에 선언된 Student st에 넣는것이다
> ```java
> class A {
>  public int Id;
>    
>    A(int Id) {
>      this.Id = Id;
>    }
>}
>A a = new A(4);
>A b = a;
>b.myId = 5;
>System.out.println(a.myId) 
> ```
>- 위 코드에선 a(참조변수)가 A의 인스턴스가 있는 주소값을 가지고있는것이고  
A b = a 라는 코드로 인해 b또한 a가 가지고있는 A의 인스턴스가 있는 주소값(Heap영역에 존재하는)을 가지게 되어 위코드를 출력했을때 5 가나오게 되는것이다. 

