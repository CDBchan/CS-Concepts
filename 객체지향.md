### 객체지향이란
- 프로그래밍에서 필요한 데이터를 추상화시켜 상태와 행위를 가진 객체를 만든후 그 객체들간의 유기적인 상호작용을 통해 로직을 구성하는 프로그래밍 방법이다.

- **장점**
	- 코드 **재사용성**이 높다
		- **상속** 등을 통하여 기존의 코드를 재사용할수 있다.
	- 코드 관리가 용이하다
		- 코드 간의 관계를 이용해 적은 노력으로 쉽게 **코드변경**이 가능하다.
	- 신뢰성이 높은 프로그래밍을 가능하게 한다.
		- 코드의 **중복제거**, 제어자와 메서드를 이용해 데이터를 보호 및 올바른 값을 유지하도록하여 **오동작**을 방지할수 있다.

---
### 용어
- 클래스 
	- 클래스란 **객체를 정의해** 놓은것, 즉 객체를 생성하는데 사용되며, 객체는 클래스에 정의된 대로 생성된다.

- 객체 
	- 프로그래밍에서 객체는 클래스에 정의된 내용대로 **메모리에 생성**된 것을 뜻한다.

- 인스턴스화
	- 클래스로부터 **객체를 만드는 과정**을 클래스의 인스턴스화 라고한다.

- 인스턴스
	- **어떤 클래스로부터 만들어진 객체**를 그 클래스의 인스턴스 라고한다.

- 콜렉션(Collection)
	- 인스턴스 여러개의 모임

---

### 프로그래밍 구조

#### 속성과 기능

- 클래스란 객체를 정의한 것이다 따라서 클래스에는 객체의 모든 **속성, 기능**이 정의되어 있다.
	
- 객체지향에서는 **속성을 멤버변수**를 통해  **기능은 메서드**를 통해 표현한다.

---
#### 캡슐화
- 캡슐화란 **클래스의 내부 변수와 메소드를 하나로 패키징** 하는 특징이다.

- 객체에 선언된 변수 또는 메소드가 어떠한 제한없이 누구나 접근할수 있다면 정상적인 객체로 보기 힘들다 따라서 캡슐화를 사용한다.

- JAVA에서는 **접근제어자**를 통해 객체의 캡슐화, 은닉화를 구현한다. 

---
### 상속
- 상속이란 **객체가 다른 객체를 상속받아 상속받은 객체의 요소를 사용**하는것을 의미한다.

- 상속을 통해 코드의 **재사용성과, 확장성, 유지보수성**, 최상위 클래스 구조를 통한 하위클래스의 동작을 예측할수 있다는점에서 **프로그램 구조에대한 이해도 향상**등.. 다양한 장점이있다.

---
### 다형성

- 다형성이란 **하나의 객체 혹은 메소드가 여러 타입을 참조**할수 있음을 의미한다.
  **즉 자식객체가 부모의 타입에 들어갈수있다.**
  
- 다형성은 크게 **객체의 다형성**, **메소드의 다형성**으로 구분된다.

**객체의 다형성**

- 객체의 다형성이란 **객체가 상속된 부모 객체의 인스턴스로 할당**될수 있음을 의미한다.
~~~ java
class Account
{
   // 메소드
}
class CheckingCard extends Account
{
      // 메소드
}
public class Main {
    public static void main(String[] args) {
      Account card = new CheckingCard();
   }
}
~~~
위 코드에서 CheckingCard 는 Account를 상속받았다. 
이때 *Account card = new Account()*로 객체를 생성하는 대신 위와같이 객체를 생성할수 있다는게 바로 다형성중 **객체의 다형성**이다.

**메소드의 다형성 **

- 메소드의 다형성이란 **메소드가 서로 동일한 이름을 가지더라도, 입력받는 파라미터가 다르면 각각 개별적인 메소드로 취급**을 의미한다. 
~~~ java
public class Main
{
  public static void main(String[] args)
	{
		System.out.println("문자");
		System.out.println(1234);
		System.out.println(true);
	}
}
~~~
- 위 코드에서 사용한 println 메소드는 입력되는 파라미터가 문자열,숫자,bool 타입으로 다  다르지만 잘 처리하는것을 볼수있는데 이러한 이유는 println메소드가 다형성을 통해 정의되어있기 때문이다..

---

### **추상화**

- 추상화란 클래스 정의시 불필요한 부분을 생략하고 객체의 속성중 중요한것에만 중점을 두어 개략화 하는것을 말한다. 
**즉 클래스들의 중요하고 공통된 성질들을 추출하여 슈퍼 클래스를 선정하는 개념이다.**

---

### **캐스팅**
- **캐스팅이란 타입을 변환**한다는 것이다.
캐스팅의 종류는 **업 캐스팅** 과 **다운 캐스팅** 2가지이다.

---
- **업 캐스팅**
- 업 캐스팅이란 **자식 클래스가 부모 클래스 타입으로 캐스팅이 되는것**을 말한다.

~~~ java
class Account
{
	// 메소드
}
class CheckingCard extends Account
{
	// 메소드
}
public class Main {
	public static void main(String[] args) {
		CheckingCard child = new CheckingCard();
		Account parent = child;
	}
}
~~~
- 위와 같은 코드가 있을때 *Account parent = child*부분이 **자식클래스가 부모 클래스 타입으로 캐스팅이 된 부분이다.**  

   업캐스팅을 통해 수퍼클래스의 참조변수 parent가 서브클래스의 인스턴스를 가리킬수 있게 된것이다.  

  또한 이때 명시적인 타입캐스팅  *Account parent = (Account) child*; 와 같이 *(Account)*를 붙여줄 필요가 없다.
  

**주의**
- 업캐스팅을 하게되면 부모의 참조변수를 통해 자식의 인스턴스를 지정한다. 따라서 **자식 클래스에 있는 속성과 메서드는 실행할수 없게 된다.**

- 업 캐스팅후 메소드 실행시, 자식클래스에서 오버라이딩한 메서드가 있을경우, **부모 클래스의 메소드가아닌 오버라이딩한 메소드가 실행되게 된다.**

**업 캐스팅 사용이유**
- 업케스팅을 하게되면 상속관계에서 상속받은 서브클래스의 개수에 상관없이 하나의 인스턴스로 묶어 관리가가능하다.

- 위 와 같은 코드에서 만약 *Account*를 상속받은 다른 서브 클래스가 있더라도 업캐스팅을 통해 *Account[] a = new Account[];* 라는 a배열을 통해 서브 클래스들을 한번에 정리하는등.. 가독성과 유지보수성을 높일수있다. 

---

- **다운 캐스팅**
  - 다운 캐스팅은 업캐스팅과 반대로 부모 클래스가 자식 클래스의 타입으로 캐스팅이 되는것을 말한다. 
  - **주의**
    - 다운캐스팅은 업캐스팅과는 반대로 **캐스팅 연산자를 생략할수 없다**
  - **다운 캐스팅 사용이유**
    - 다운캐스팅은 우리가 업캐스팅한 객체를 다시 자식클래스 타입의 객체로 되돌리는데 목적이 있다.

---
### **instanceof 연산자**

  - instanceof 연산자를 통해 **어느 객체 변수가 어느 클래스 타입인지 판별해준다** (return 값은 true/false).

~~~ java
class Account
{
	// 메소드
}
class CheckingCard extends Account
{
	// 메소드
}
public class Main {
	public static void main(String[] args) {
		CheckingCard child = new CheckingCard();
		Account parent = new Account();
		System.out.println(parent instanceof CheckingCard); // false
		System.out.println(parent instanceof Account); // true
		System.out.println(child instanceof Account); // true
	}
}
~~~
 - 위 코드에서 보면 parent는 CheckingCard(자식)의 인스턴스가 아니기때문에 false가 출력된다.

 - 반면 3번째 출력문에서 child는 Account(부모)의 인스턴스로도 보기때문에 false가 아닌 true가 나온다.